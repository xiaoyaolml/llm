# test18：零开销抽象的边界与基准陷阱

> 对应源码：`test18.cpp`
> 标准：C++17
> 目标：补充 `test5`，回答“零开销在什么前提下成立？”

---

## 编译运行

```bash
g++ -std=c++17 -O2 -Wall -Wextra -o test18 test18.cpp && ./test18
# 或
cl /std:c++17 /O2 /W4 /EHsc test18.cpp
```

---

## 核心结论

- 零开销是“可达目标”，不是“任何抽象、任何场景都绝对为零”。
- 性能结果经常是“分派方式 + 内存布局 + 分配策略”的耦合结果。
- 文档中的基准数据应被视为“样例趋势”，不是跨平台固定数字。

---

## Case 1：模板 / 函数指针 / std::function

`test18.cpp` 对比了三类调用路径：

- 模板可调用对象（最易内联）
- 函数指针（一次间接调用）
- `std::function`（类型擦除，可能带额外间接层）

**解读**：
- 小函数热路径里，模板通常最容易达到“近似零额外开销”。
- `std::function` 不是“必慢”，但在极热路径经常更难被优化到与模板同级。

---

## Case 2：虚调用 vs 连续内存

示例不是单独比较“virtual”关键字，而是比较：

- 连续内存上的直接运算
- 堆对象图 + 虚调用

**解读**：
- 很多性能损失来自缓存局部性与指针追踪，而不只是 `vtable` 间接跳转本身。
- 若虚函数方案采用对象池或更好的布局，差距会缩小。

---

## Case 3：所有权对象 vs 视图对象

对比 `std::string::substr()`（拷贝）和 `std::string_view::substr()`（视图）。

**解读**：
- `string_view` 在“只读切片”场景通常接近零开销。
- 但它不拥有内存，必须保证源字符串生命周期覆盖视图使用期。

---

## 与 test5 的衔接

本专题对 `test5` 的补充重点：

1. 把“零开销”从结论口号变成“有条件成立的工程判断”。
2. 为 `variant vs virtual`、`模板 vs std::function` 提供更可解释的基准框架。
3. 强化“以汇编与实测为准”的方法论。

---

## 建议实践

- 所有“零开销”结论，至少做两种验证：
  - 编译器反汇编（Godbolt 或本地 `-S`）
  - 目标平台基准（固定编译器版本与 CPU）
- 在文档中避免“完全相同/总是更快”这类绝对表述。
- 为每个基准附上数据规模、预热方式、编译参数和硬件信息。
