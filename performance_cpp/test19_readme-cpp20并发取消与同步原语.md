# test19：C++20 并发补充 —— 协作取消与同步原语

> 对应源码：`test19.cpp`
> 关联章节：`test6` 第1章（thread/join）与第13章（线程池）
> 标准：C++20

---

## 为什么补这个专题

`test6` 的主线是 C++17 并发。对现代工程而言，还需要补齐三个 C++20 能力：

1. `std::jthread + std::stop_token`：协作取消，解决“线程如何优雅停机”。
2. `std::latch`：一次性同步点，适合“等一批任务全部完成”。
3. `std::barrier`：多阶段同步，适合迭代式并行算法。

这三者在低延迟系统里都非常实用，尤其在“有界停机时间”和“阶段对齐”场景。

---

## 编译

```bash
g++ -std=c++20 -O2 -pthread -o test19 test19.cpp
# 或
cl /std:c++20 /O2 /EHsc test19.cpp
```

---

## 关键点总结

### 1) jthread + stop_token

- `std::thread` 只有 `join/detach`，没有标准化取消协议。
- `std::jthread` 析构自动 `join`，并提供 `request_stop()`。
- 取消是**协作式**：线程必须主动轮询 `stop_requested()`。

> NOTE：这不是“强杀线程”。如果工作线程不检查 stop token，就不会及时退出。

### 2) latch

- 一次性倒计时门闩。
- 常用模式：N 个 worker 完成后，主线程统一继续。
- 对比条件变量，`latch` 在“固定参与者 + 一次性”场景更直接。

### 3) barrier

- 可循环复用的阶段同步原语。
- 每一轮所有参与者到齐后才进入下一阶段。
- 适合迭代求解、并行 pipeline 的阶段边界控制。

---

## 与 test6 的衔接建议

- 如果项目升级到 C++20：
  - `JoinThread` 可以逐步迁移到 `std::jthread`。
  - 线程池停机流程可加 `stop_token` 协作退出。
  - 分阶段并行任务可优先尝试 `barrier`，替代手写计数 + condvar。

- 如果仍停留在 C++17：
  - 保留 `JoinThread` + `atomic<bool>` 停机标记方案；
  - 保持“可中断等待 + 明确退出协议”的设计。

---

## 本专题价值

它补的是“如何正确结束并发系统”和“如何在阶段边界保持一致性”——这两点是从教程代码走向生产系统时最容易踩坑的地方。`test19` 作为 `test6` 的后续专题，可直接作为升级 C++20 的迁移样板。
