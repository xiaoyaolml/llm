# 📚 嵌入式 C 语言笔试复习资料

*整理：大胖超 😜 | 更新时间：2026-02-28*

---

## 📋 目录

1. C 语言基本语法
2. 数组
3. 结构体
4. 联合体 (共用体)
5. 指针
6. 嵌入式 C 语言特有考点
7. 经典选择题/判断题
8. 经典问答题

---

## 一、C 语言基本语法

### 1.1 数据类型

| 类型 | 32 位系统 | 64 位系统 | 说明 |
|------|----------|----------|------|
| char | 1 字节 | 1 字节 | -128~127 (signed) / 0~255 (unsigned) |
| short | 2 字节 | 2 字节 | -32768~32767 |
| int | 4 字节 | 4 字节 | 依赖平台 |
| long | 4 字节 | 8 字节 | **注意平台差异** |
| long long | 8 字节 | 8 字节 | C99 标准 |
| float | 4 字节 | 4 字节 | 单精度 |
| double | 8 字节 | 8 字节 | 双精度 |
| 指针 | 4 字节 | 8 字节 | **所有指针大小相同** |

### 1.2 存储类型

```c
auto      // 自动变量（默认）
static    // 静态变量（生命周期延长）
register  // 寄存器变量（建议，不一定生效）
extern    // 外部声明
```

### 1.3 作用域规则

| 存储类型 | 作用域 | 生命周期 | 默认值 |
|----------|--------|----------|--------|
| 局部变量 | 函数内 | 函数调用期间 | 随机值 |
| 全局变量 | 整个文件 | 程序运行期间 | 0 |
| static 局部 | 函数内 | 程序运行期间 | 0 |
| static 全局 | 本文件内 | 程序运行期间 | 0 |

### 1.4 const 关键字

```c
const int a;        // a 是常量，不可修改
int const a;        // 同上
const int *p;       // p 指向常量，*p 不可改，p 可改
int * const p;      // p 是常量指针，p 不可改，*p 可改
const int * const p;// p 是常量指针，指向常量，都不可改
```

### 1.5 volatile 关键字 ⭐⭐⭐

```c
volatile int flag;  // 告诉编译器不要优化，每次都从内存读取
```

**使用场景：**
- 内存映射的硬件寄存器
- 中断服务程序中修改的全局变量
- 多任务共享的标志位

---

## 二、数组

### 2.1 数组定义与初始化

```c
int arr[5];                    // 未初始化
int arr[5] = {1, 2, 3, 4, 5};  // 完全初始化
int arr[] = {1, 2, 3};         // 自动推断大小
int arr[5] = {1, 2};           // 剩余元素为 0
int arr[5] = {0};              // 全部初始化为 0
```

### 2.2 数组名与指针

```c
int arr[5] = {1, 2, 3, 4, 5};

arr      // 数组首元素地址，等价于 &arr[0]
arr + 1  // 指向 arr[1]，步长为 sizeof(int)
&arr     // 整个数组的地址
&arr + 1 // 跳过整个数组，步长为 sizeof(arr)
```

**关键区别：**
```c
int arr[10];
int *p = arr;

sizeof(arr)  // 40 (10 * 4)
sizeof(p)    // 8 (64 位系统指针大小)
```

### 2.3 二维数组

```c
int arr[3][4];           // 3 行 4 列
int arr[3][4] = {0};     // 全部初始化为 0

// 内存布局：行优先
arr[0][0], arr[0][1], arr[0][2], arr[0][3],
arr[1][0], arr[1][1], ...

// 作为函数参数
void func(int arr[][4], int rows);
void func(int (*arr)[4], int rows);  // 等价写法
```

### 2.4 常见考点

```c
// 考点 1：数组越界
int arr[5];
arr[5] = 10;  // ❌ 越界！有效索引 0-4

// 考点 2：数组不能整体赋值
int a[5] = {1,2,3,4,5};
int b[5];
b = a;  // ❌ 错误！

// 正确做法
memcpy(b, a, sizeof(a));

// 考点 3：字符串数组
char str[] = "hello";     // 6 字节（含\0）
char *p = "hello";        // 字符串常量，不可修改
```

---

## 三、结构体

### 3.1 结构体定义

```c
// 定义方式 1
struct Student {
    char name[20];
    int age;
    float score;
};

// 定义方式 2（带 typedef）
typedef struct {
    char name[20];
    int age;
} Student;

// 定义方式 3（自引用）
struct Node {
    int data;
    struct Node *next;  // ✅ 可以
    // Node *next;      // ❌ 此时 Node 未定义
};
```

### 3.2 结构体内存对齐 ⭐⭐⭐

**对齐规则：**
1. 第一个成员从偏移量 0 开始
2. 每个成员对齐到 `min(成员大小，对齐系数)` 的整数倍
3. 结构体总大小是对齐系数的整数倍

```c
// 默认对齐系数 = 最大成员大小

struct A {
    char a;      // 偏移 0，占 1 字节
    // 填充 3 字节
    int b;       // 偏移 4，占 4 字节
    char c;      // 偏移 8，占 1 字节
    // 填充 3 字节
};               // 总大小：16 字节

struct B {
    char a;      // 偏移 0
    char c;      // 偏移 1
    // 填充 2 字节
    int b;       // 偏移 4
};               // 总大小：8 字节（优化后）
```

**修改对齐系数：**
```c
#pragma pack(1)  // 1 字节对齐（无填充）
struct A {
    char a;
    int b;
    char c;
};               // 总大小：6 字节
#pragma pack()   // 恢复默认
```

### 3.3 结构体作为函数参数

```c
// 方式 1：传值（拷贝，效率低）
void func(struct Student s);

// 方式 2：传指针（推荐）
void func(struct Student *s);
void func(const struct Student *s);  // 不修改时用 const

// 方式 3：传指针（typedef 后）
void func(Student *s);
```

---

## 四、联合体 (共用体)

### 4.1 联合体定义

```c
union Data {
    int i;
    float f;
    char str[20];
};

// 所有成员共享同一块内存
// 大小 = 最大成员大小（考虑对齐）
```

### 4.2 结构体 vs 联合体

| 特性 | 结构体 (struct) | 联合体 (union) |
|------|----------------|---------------|
| 内存 | 各成员独立 | 共享同一内存 |
| 大小 | 各成员之和 + 对齐填充 | 最大成员大小 |
| 同时使用 | 可同时访问所有成员 | 同一时间只能用一个 |

### 4.3 联合体应用

```c
// 应用 1：类型转换
union {
    float f;
    unsigned int i;
} conv;

conv.f = 3.14f;
printf("%x\n", conv.i);  // 查看浮点数的二进制表示

// 应用 2：变长数据
typedef struct {
    int type;
    union {
        int i;
        float f;
        char str[20];
    } data;
} Variant;

// 应用 3：大小端检测
union {
    int i;
    char c;
} endian;

endian.i = 1;
if (endian.c == 1) {
    // 小端
} else {
    // 大端
}
```

---

## 五、指针 ⭐⭐⭐⭐⭐

### 5.1 指针基础

```c
int a = 10;
int *p = &a;

p      // 指针变量，存储地址
*p     // 解引用，得到 a 的值
&p     // 指针变量本身的地址
```

### 5.2 指针运算

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;

p + 1      // 移动 sizeof(int) = 4 字节
p++        // 指向下一个元素
*(p + 2)   // 等价于 arr[2] = 30
p[2]       // 等价于 *(p + 2)
```

### 5.3 指针数组 vs 数组指针

```c
// 指针数组（数组，元素是指针）
int *arr[5];      // 5 个 int 指针

// 数组指针（指针，指向数组）
int (*p)[5];      // 指向含 5 个 int 的数组

// 函数指针数组
int (*func_arr[3])(int, int);
```

### 5.4 二级指针

```c
int a = 10;
int *p = &a;
int **pp = &p;

**pp  // 得到 a 的值 (10)

// 应用：修改指针本身
void changePtr(int **pp) {
    *pp = malloc(100);
}
```

### 5.5 函数指针

```c
// 定义
int add(int a, int b) { return a + b; }
int (*func)(int, int) = add;

// 调用
int result = func(3, 4);  // 7
result = (*func)(3, 4);   // 等价

// 回调函数
void callback(void (*func)(int)) {
    func(10);
}
```

### 5.6 指针与 const

```c
const int *p1;     // 指向常量的指针，*p1 不可改
int * const p2;    // 常量指针，p2 不可改
const int * const p3;  // 都不可改
```

### 5.7 野指针与空指针

```c
int *p;           // 野指针（未初始化）
int *p = NULL;    // 空指针（安全）
int *p = malloc(...);  // 动态分配

// 使用后要及时置空
free(p);
p = NULL;
```

### 5.8 常见指针面试题

```c
// 1. 下面代码输出什么？
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;
printf("%d\n", *p++);  // 1 (先取值后自增)
printf("%d\n", *++p);  // 3 (先自增后取值)

// 2. 指针类型转换
int a = 0x12345678;
char *p = (char*)&a;
printf("%x\n", *p);  // 小端：78，大端：12

// 3. 数组与指针
char str[] = "hello";
char *p = "hello";
// str 可修改，p 指向字符串常量不可修改
```

---

## 六、嵌入式 C 语言特有考点

### 6.1 位操作

```c
// 置位（设为 1）
reg |= (1 << n);

// 清零（设为 0）
reg &= ~(1 << n);

// 取反
reg ^= (1 << n);

// 检查某位
if (reg & (1 << n)) { ... }

// 提取某几位
value = (reg >> start) & mask;
```

### 6.2 宏定义

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define SQUARE(x) ((x) * (x))
#define OFFSETOF(type, member) ((size_t)&(((type*)0)->member))

// 条件编译
#ifdef DEBUG
    printf("debug\n");
#endif

#if defined(CONFIG_A)
    // ...
#endif
```

### 6.3 中断服务程序

```c
// ISR 注意事项：
// 1. 无返回值
// 2. 无参数
// 3. 不能调用可能阻塞的函数
// 4. 尽量短小
// 5. 共享变量用 volatile

volatile int flag = 0;

void ISR_Handler(void) {
    flag = 1;  // 设置标志
}

int main(void) {
    while (1) {
        if (flag) {
            flag = 0;
            // 处理
        }
    }
}
```

### 6.4 内存映射

```c
// 访问硬件寄存器
#define REG_BASE  0x40000000
#define REG_CTRL  (*(volatile unsigned int *)(REG_BASE + 0x00))
#define REG_DATA  (*(volatile unsigned int *)(REG_BASE + 0x04))

// 使用
REG_CTRL = 0x01;
unsigned int val = REG_DATA;
```

### 6.5 大小端

```c
// 小端：低位在低地址
// 大端：高位在低地址

// 检测函数
int check_endian(void) {
    union {
        unsigned int i;
        unsigned char c;
    } test;
    test.i = 1;
    return test.c;  // 1=小端，0=大端
}
```

---

## 七、经典选择题/判断题

### 选择题

**1. 以下哪个是正确的指针定义？**
- A. int p;
- B. int *p; ✅
- C. *int p;
- D. int p*;

**2. sizeof(char) 的值是？**
- A. 1 ✅
- B. 2
- C. 4
- D. 依赖平台

**3. 以下代码输出？**
```c
int arr[3] = {1, 2, 3};
printf("%d", arr[3]);
```
- A. 0
- B. 随机值 ✅
- C. 编译错误
- D. 运行错误

**4. 结构体对齐的目的是？**
- A. 节省内存
- B. 提高访问速度 ✅
- C. 代码美观
- D. 无意义

**5. volatile 的作用是？**
- A. 定义常量
- B. 防止编译器优化 ✅
- C. 定义变量
- D. 加速程序

**6. 以下哪个不能用于位操作？**
- A. &
- B. |
- C. && ✅
- D. ^

**7. 指针 p 加 1，实际地址增加？**
- A. 1 字节
- B. 2 字节
- C. 4 字节
- D. sizeof(*p) ✅

**8. 联合体大小等于？**
- A. 各成员之和
- B. 最大成员大小 ✅
- C. 最小成员大小
- D. 随机

### 判断题

1. 数组名是一个常量指针。 (✅)
2. 结构体可以整体赋值。 (✅)
3. 联合体可以同时访问所有成员。 (❌)
4. 指针可以为 NULL。 (✅)
5. const 变量一定不能修改。 (❌，可通过指针修改)
6. static 全局变量可以在其他文件访问。 (❌)
7. 中断服务程序可以有返回值。 (❌)
8. 宏定义需要分号结尾。 (❌)
9. 所有指针在 32 位系统都是 4 字节。 (✅)
10. 数组可以作为函数返回值。 (❌)

---

## 八、经典问答题

### Q1: 简述 const 和 volatile 的区别

**答案：**
- const：表示只读，告诉编译器和程序员该变量不应被修改
- volatile：表示易变，告诉编译器不要对该变量进行优化，每次都从内存读取
- 两者可同时使用：const volatile int reg;（如硬件状态寄存器）

### Q2: 结构体和联合体的区别

**答案：**
1. 内存分配：结构体各成员独立，联合体共享
2. 大小：结构体=各成员和 + 对齐，联合体=最大成员
3. 使用：结构体可同时访问所有成员，联合体同一时间只能用一个

### Q3: 指针和数组的区别

**答案：**
1. 本质：指针是变量，数组是连续内存块
2. sizeof：指针是指针大小，数组是总大小
3. 赋值：指针可重新指向，数组名是常量
4. 作为参数：数组退化为指针

### Q4: 什么是内存对齐？为什么要对齐？

**答案：**
- 内存对齐：数据在内存中的起始地址是其大小的整数倍
- 原因：CPU 访问对齐的内存更快，某些架构访问未对齐内存会出错
- 牺牲空间换时间

### Q5: 如何设置和清除一个变量的某一位？

**答案：**
```c
// 设置第 n 位
reg |= (1 << n);

// 清除第 n 位
reg &= ~(1 << n);

// 切换第 n 位
reg ^= (1 << n);
```

### Q6: 中断服务程序的注意事项

**答案：**
1. 无返回值、无参数
2. 不能调用可能阻塞的函数（如 malloc、printf）
3. 尽量短小，复杂处理交给主循环
4. 共享变量用 volatile 修饰
5. 注意重入问题

### Q7: 什么是野指针？如何避免？

**答案：**
- 野指针：未初始化或已释放但仍使用的指针
- 避免方法：
  1. 定义时初始化为 NULL
  2. 释放后置为 NULL
  3. 使用前检查是否为 NULL
  4. 不要返回局部变量地址

### Q8: static 关键字的作用

**答案：**
1. 修饰局部变量：延长生命周期到程序结束
2. 修饰全局变量：限制作用域为本文件
3. 修饰函数：限制作用域为本文件

### Q9: 大小端区别及检测

**答案：**
- 小端：低位字节在低地址（x86、ARM 默认）
- 大端：高位字节在低地址（网络字节序）
- 检测：用联合体或指针类型转换

### Q10: 写一个宏，计算结构体成员的偏移量

**答案：**
```c
#define OFFSETOF(type, member) ((size_t)&(((type*)0)->member))
```

---

## 📝 考前冲刺建议

1. **重点复习**：指针、结构体对齐、volatile、位操作
2. **手写代码**：练习字符串操作、链表操作
3. **理解概念**：不要死记硬背，理解原理
4. **时间分配**：选择题快速过，问答题留足时间

---

*祝笔试顺利！加油！💪*
